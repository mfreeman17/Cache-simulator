
'''
DO NOT EDIT THIS FILE
Base file for testing cache functions
Credit: R. Martin (W&M), A. Jog (W&M), Ramulator (CMU)

CPU Trace Driven: This simulator directly reads instruction traces 
from a file (stored in ../Traces), and simulates a simplified model 
of a "core" that generates memory requests to the DRAM subsystem. Each line 
in the trace file represents a memory request, and can have one of the following 
two formats. 

<num-cpuinst> <addr-read>: For a line with two tokens, the 
first token represents the number of CPU (i.e., non-memory) instructions 
before the memory request, and the second token is the decimal address of 
a read. These traces can either be artificial or derived from SPEC 2006 
suite (https://www.spec.org/) (using PIN Tool from Intel)

<num-cpuinst> <addr-read> <addr-writeback>: For a line with 
three tokens, the third token is the decimal address of the 
writeback request, which is the dirty cache-line eviction caused 
by the read request before it. 

This simulator does not consider the third token at all and we 
will ignore it for our assignments.

Example command line:
python sim_424.py test.trace 16 1 8
'''

from math import log2
import random
import sys
import os
import numpy as np
from cache_424_w import Cache

if __name__ == "__main__":

    try:
        if sys.argv[1] == 'all':
            files = os.listdir('../Traces/')
        else:
            files = [sys.argv[1]]
        cacheSize = int(sys.argv[2])
        ways = int(sys.argv[3])
        block_size = int(sys.argv[4])

    except:
        print('main.py trace cacheSize(Bytes) #ofWays blockSize(Bytes)')

    cache = Cache(cacheSize, ways, block_size)
    cache.reset()

    for file in files:
        print(file)

        cache.reset()
        compute = 0

        with open('../Traces/{}'.format(file)) as f:
            trace = f.readlines()

        for t in range(len(trace)):
            if t % 1000 == 0:
                print('Processing your program trace, progress so far =', int(t / len(trace) * 100), '%')
            compute += int(trace[t].split(' ')[0])
            address = int(trace[t].split(' ')[1])


            found = cache.find(address)
            if found==False:
                cache.load(address)

            # print('set and tag of', hex(address), 'is', cache.find_set(address), cache.find_tag(address))
            # if found:
            #     print('address', hex(address), 'CACHE HIT. Good Job.')
            # else:
            #     print('address', hex(address), 'CACHE MISS. Loading from memory.')
        
        load_requests = len(trace)
        misses = load_requests - cache.hit
        miss_rate = misses/load_requests 
        amat = cache.hitlatency + miss_rate*cache.misspenalty
        avg_cpi_ideal = 1.0

        print('total cache misses', misses)
        print('miss_rate', miss_rate)
        print('AMAT', amat)
        print('CPI_stall', int((avg_cpi_ideal + miss_rate*cache.misspenalty + (load_requests*miss_rate*cache.misspenalty)/(load_requests + compute))))
        #print('CPI_aj is', int((amat*load_requests + compute*avg_cpi_ideal)/(load_requests + compute) + miss_rate*cache.misspenalty))
        print('Finished processing your program trace, progress =', ((t+1) / len(trace)) * 100, '%')
